<html>
<head>
<title>gee.js</title>
<link href="style.css" media="screen" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="build/gee.min.js"></script> 
<script type="text/javascript" src="prettify.js"></script>
<script type="text/javascript">
window.onload = function() {

	prettyPrint();
	
	var g = new GEE({width: 513, height: 513, container:  document.getElementById('canvas-holder')});

	var signs = [];
	var topSigns = [];
	
	g.ctx.font = '15px "Croog", sans-serif';
	
	var line = function(ctx, x1, y1, x2, y2) {
		
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();
	}
	
	g.draw = function() {
	
		g.ctx.fillStyle = '#eee';
		g.ctx.fillRect(0, 0, g.width, g.height);	
		
		g.ctx.shadowColor = '#fff';
		g.ctx.shadowBlur = 0;
		g.ctx.shadowOffsetY = 1;
		g.ctx.shadowOffsetX = 1;
		
		g.ctx.textAlign = 'left';
		g.ctx.fillStyle = '#666';
		
		if (false) {
			g.ctx.fillText('g.keyPressed: ' + g.keyPressed, 30, 40);
			g.ctx.fillText('g.mousePressed: ' + g.mousePressed, 30, 60);
			g.ctx.fillText('g.frameRate: ' + g.frameRate, 30, 80);
			g.ctx.fillText('g.frameTime: ' + g.frameTime, 30, 100);
			g.ctx.fillText('g.frameCount: ' + g.frameCount, 30, 120);
		}
		
		if (false) {
			
			var p = 6;
			var h2 = Math.round(g.height/2)+0.5;
			var w2 = Math.round(g.width/2)+0.5;
			
			g.ctx.fillStyle = '#bbb';		
			g.ctx.font = 'italic 12px Georgia, serif';
			g.ctx.textAlign = 'center';
			g.ctx.fillText('g.width: ' + g.width, g.width*3/4.0, h2+3);
			g.ctx.fillText('g.height: ' + g.height, w2, g.height*3.0/4+4);
			
			g.ctx.strokeStyle = '#ddd';
			
			g.ctx.shadowOffsetY = 0;
			g.ctx.shadowOffsetX = 0;
			
			line(g.ctx, p, h2, g.width*3/4-45, h2);
			line(g.ctx, g.width*3/4+45, h2, g.width-p, h2);
			
			line(g.ctx, w2, p, w2, g.height*3/4-15);
			line(g.ctx, w2, g.height*3/4+15, w2, g.height-p);
			
		}
		
		for (var i = 0; i < signs.length; i++) {
			signs[i].update();
		}
		for (var i = 0; i < signs.length; i++) {
			signs[i].draw(g.ctx);
		}
		for (var i = 0; i < topSigns.length; i++) {
			topSigns[i].update();
		}
		for (var i = 0; i < topSigns.length; i++) {
			topSigns[i].draw(g.ctx);
		}
	};
	
	g.mousedrag = function() {
		var s = new Sign(signs, 'g.mousedrag()', g.mouseX, g.mouseY, 1);
		s.boxColor = '#333';
		s.fontColor = '#fff';

	}
	g.mousemove = function() {
		var s = new Sign(signs, 'g.mousemove()', g.mouseX, g.mouseY, 1);
		
	}
	g.mouseup = function() {
		var s = new Sign(topSigns, 'g.mouseup()', g.mouseX, g.mouseY, 1.5);
		s.liftVel = 7+Math.random()*3;
		s.boxColor = '#e61d5f';
		s.fontColor = '#fff';
	}
	
	g.mousedown = function() {
		var s = new Sign(topSigns, 'g.mousedown()', g.mouseX, g.mouseY, 1.5);
		s.liftVel = 20+Math.random()*1;
		s.boxColor = '#00aeff';
		s.fontColor = '#fff';
	}
	
	g.keydown = function() {
		
		new Ball(topSigns, g.keyCode);

	}
	
	var Ball = function(arr, str) {
		
		var acc = 0.2;
		var radius = 60;
		var yvel = (-15 - Math.random()*18)*9.5;
		var xvel = (Math.random()*3 - 2)*6;
		var x = Math.random()*(g.width*3/4.0) + g.width/8.0;
		var y = g.height;
		var drag = 0.6;
		var ss = Math.random()*0.2 + 0.5;
		var r = 0;
		var age = 0;
		var deathAge = 45;
		var deathLength = 3 + parseInt(Math.random()*5);
		var rs = (Math.random()*0.01-0.005);
		this.update = function() { 	
			yvel += acc;
			yvel *= drag;
			xvel *= drag;
			x += xvel;
			y += yvel;
			r += rs;
			if (age > deathAge) {
				this.die();
				this.return;
			}
		}
		this.die = function(c) {
			arr.splice(arr.indexOf(this), 1);
		}
		this.draw = function(c) {
			c.fillStyle = '#0fa954';
			c.save();
			c.globalAlpha = 0.9;
			c.translate(x, y);
			if (age > deathAge - deathLength) {
				var s = age - (deathAge - deathLength);
				s = (deathLength-s)/deathLength;
				s = Math.sqrt(s);
				if (ss*s <= 0) {
					c.restore();
					return;
				}
				c.scale(ss*s, ss*s);
			} else { 
				if (ss <= 0) {
					c.restore();
					return;
				}
				c.scale(ss, ss);
			}
			c.rotate(r);
			c.shadowBlur = 0;		
			c.shadowColor = 'rgba(0,0,0,0)';
			c.shadowOffsetY = 0;
			c.shadowOffsetX = 0;
			c.beginPath()
			c.arc(0, 0, radius, 0, Math.PI*2, false);
			c.fill();
			c.fillStyle = '#fff';			
			c.font = '60px "Croog", sans-serif';
			c.textAlign = 'center';
			c.globalAlpha = 1;
			c.fillText(str, 0, 20);
			c.restore();
			age++;
		}
		arr.push(this);
	}
	
	var Sign = function(arr, str, x, y, ss) {
		var ss = ss || 1;
		var spikeWidth = 8;
		var spikeHeight = 6;
		var boxWidth = 60;
		var boxHeight = 30;
		var arr = arr;
		this.boxColor = '#fff';
		this.fontColor = '#333';
		var r = Math.random()*Math.PI/4 - Math.PI/8;
		var age = 0;
		var deathAge = 45;
		this.liftVel = Math.random()*7 + 1;
		var drag = 0.6 + Math.random()*0.33;
		var lift = 0;
		var grav = 0.03;
		var oggrav = 0.02;
		var xv = g.mouseX - g.pmouseX;
		var yv = g.mouseY - g.pmouseY;
		xv *= 1.3;
		yv *= 1.3;
		var deathLength = 3 + parseInt(Math.random()*5);
		this.die = function() {
			arr.splice(arr.indexOf(this), 1);
		}
		this.update = function() {
		
			if (age > deathAge) {
				this.die();
				this.return;
			}
			
		}
		this.draw = function(c) {
			
			c.save();
			c.translate(x-xv, y-yv);
			
			xv *= drag;
			yv *= drag;
			
			
			c.rotate(r);

			lift -= this.liftVel
			this.liftVel *= drag;
			this.liftVel -= grav;
			
			
			c.translate(0, lift);
			c.scale(ss, ss);
			
			if (age > deathAge - deathLength) {
				var s = age - (deathAge - deathLength);
				s = (deathLength-s)/deathLength;
				s = Math.sqrt(s);
				c.scale(s, s);
			} else { 
				c.scale(1, 1);
			}
			
			g.ctx.fillStyle = this.boxColor;
			
			c.shadowBlur = 2;
			c.shadowOffsetY = 2;
			c.shadowOffsetY = 2;
			c.shadowColor = 'rgba(0,0,0,0.1)';
			c.beginPath();
			c.moveTo(0, 0);
			c.lineTo(- spikeWidth/2, -spikeHeight);
			c.lineTo(- boxWidth, -spikeHeight);
			c.lineTo(- boxWidth, -spikeHeight-boxHeight);
			c.lineTo(  boxWidth, -spikeHeight-boxHeight);
			c.lineTo(  boxWidth, -spikeHeight);
			c.lineTo(  spikeWidth/2, -spikeHeight);
			c.fill();
			
			c.font = '11px "Croog", sans-serif';
			c.shadowColor = 'rgba(0,0,0,0)';
			c.shadowBlur = 0;
			c.fillStyle = this.fontColor;
			c.textAlign = 'center';
			c.fillText(str, 0, -spikeHeight-boxHeight/2+3);
			age++;
			c.restore();
		}
		
		arr.push(this);
		
	}
		
	}
</script>
</head>
<body>
<div id="container">

<div id="canvas-holder">

</div>

<p><strong>gee.js</strong> is a library that makes it quick to start sketching with the HTML5 <code>&lt;canvas&gt;</code>.</p>

<ul>
	<li><a href="build/gee.min.js"><strong>Download the minified source</strong></a> <small>[2kb]</small></li>
	<li><a href="template/fullscreen.html">Download a fullscreen template with HTML5 boilerplate code</a></li>
	<li><a href="http://github.com/georgealways/gee">Contribute on GitHub!</a></li>
</ul>

<h2>Creating a fullscreen 2D <code>&lt;canvas&gt;</code></h2>
<pre class="prettyprint">&lt;script type="text/javascript" src="gui.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
 
window.onload = function() {
 
   var g = new <code>GEE</code>( { fullscreen: true } );
   
   g.draw = function() {
   
      g.ctx.clearRect( 0, 0, g.width, g.height );
      g.ctx.fillText( g.frameCount, 10, 10 );
      
   };
   
   g.mousedrag = function() {
   	
      g.ctx.beginPath();
      g.ctx.moveTo( g.pmouseX, g.pmouseY );
      g.ctx.lineTo( g.mouseX, g.mouseY );
      g.ctx.stroke();
   	
   };

};

&lt;/script&gt;</pre> 

<p>
Passing the parameter <code>fullscreen:true</code> to <code>GEE</code>'s constructor automatically removes padding/margin from the HTML document and appends a <code>&lt;canvas&gt;</code> to the body that scales with the window.</p><p>You can override event properties such as <code>draw</code> and <code>mousedrag</code> to implement the behavior of your choosing. <a href="#props">A complete list</a> of <code>GEE</code>'s properties are below.</p>
</p>

<hr/>

<h2>Parameters for <code>GEE</code>'s constructor</h2>

<pre class="prettyprint">
var g = new GEE( { width: 600, height: 480, container: document.body } );

// &hellip; does the same thing as &hellip;

var g = new GEE( { width: 600, height: 480 } );
document.body.appendChild( g.domElement );
</pre>

<pre class="prettyprint">
var g = new GEE( { width: 200, 
                   height: 200, 
                   context: 'experimental-webgl',
                   container: document.getElementById( 'canvas-holder' ),
                   fallback: function() { alert( "You don't have WebGL." ) }
                   } );
</pre>
<dl>
<dt class="string">context</dt><dd>type of rendering context<span class="hint">e.g. '2d' or 'experimental-webgl' &mdash; defaults to '2d'</span></dd>
<dt class="boolean">fullscreen</dt><dd>if true, automatically removes padding/margin from the HTML document and appends a <code>&lt;canvas&gt;</code> to the body that scales with the window.<span class="hint">If true, ignores following parameters  &mdash; defaults to false</span></dd>
<hr/>
<dt class="dom">container</dt><dd>DOM element to which we append the <code>&lt;canvas&gt;</code> element<span class="hint">If you don't specify this parameter, you need to manually append the <code>GEE</code> domElement property to another DOM element on the page.</span></dd>
<dt class="number">width</dt><dd>initial width of the <code>&lt;canvas&gt;</code> element</dd>
<dt class="number">height</dt><dd>initial height of the <code>&lt;canvas&gt;</code> element</dd>
<dt class="function">fallback</dt><dd>fires if something goes wrong</dd>
</dl>
<div class="clear"></div>
<hr/>
<h2><a name="props"></a>Properties of a <code>GEE</code> object</h2>

<pre class="prettyprint">
// a GEE object has lots of properties.

// Some you can set &hellip;
g.frameRate = 30;
g.height = 200;
g.mousedown = function() { console.log( 'You pressed the canvas' ) };
g.keydown = function() { console.log( 'You pressed ' + g.key ) };
g.loop = false;


g.draw = function() {

   // Some you just read &hellip;
   
   if ( g.mouseX > g.width/2 ) {
      g.ctx.fillRect( g.mouseX, g.mouseY, 10, 10 );
   }
	
}
</pre>

<p>Below is a list of all of <code>GEE</code>'s properties. The &nbsp;<img src="lock.gif" alt="lock" />&nbsp; indicates that a property is read-only.</p>

<dl id="doc">
<dt class="special readonly">ctx</dt>	<dd>current rendering context</dd>
<dt class="dom readonly">domElement</dt>	<dd>the DOM <code>&lt;canvas&gt;</code> element</dd>

<hr/>

<dt class="number">width</dt>	<dd>current width of the <code>&lt;canvas&gt;</code> element</dd>
<dt class="number">height</dt>	<dd>current height of the <code>&lt;canvas&gt;</code> element</dd>

<dt class="number">frameRate</dt>	<dd>sets desired frames per second<br/>
										returns actual frames per second</dd>
										
<dt class="number">frameTime</dt>	<dd>sets desired milliseconds per frame<br/>
										returns actual milliseconds per frame</dd>

<dt class="number readonly">frameCount</dt>	<dd>number of frames drawn</dd>
<hr/>

<dt class="function">draw</dt>	<dd>fires every frame, as long as the <code>&lt;canvas&gt;</code> is visible</dd>

<dt class="function">mousedown</dt>	<dd>fires when the mouse is pressed on the <code>&lt;canvas&gt;</code></dd>
<dt class="function">mouseup</dt>	<dd>fires when the mouse is released from the <code>&lt;canvas&gt;</code></dd>

<dt class="function">mousemove</dt>	<dd>fires while the mouse is moving over the <code>&lt;canvas&gt;</code></dd>
<dt class="function">mousedrag</dt>	<dd>fires while the mouse is dragged over the <code>&lt;canvas&gt;</code></dd>

<dt class="function">keydown</dt>	<dd>fires while a key is supressed <span class="hint">If the key is held down then keydown will execute repeatedly.</span></dd>
<dt class="function">keyup</dt>	<dd>fires when a key is released</dd>

<hr/>

<dt class="number readonly">mouseX</dt>	<dd>the x position of the mouse<span class="hint">0 is the left side of the <code>&lt;canvas&gt;</code> element.</span></dd>
<dt class="number readonly">mouseY</dt>	<dd>the y position of the mouse<span class="hint">0 is the top of the <code>&lt;canvas&gt;</code> element.</span></dd>
<dt class="number readonly">pmouseX</dt>	<dd>the previous x position of the mouse</dd>
<dt class="number readonly">pmouseY</dt>	<dd>the previous y position of the mouse</dd>

<hr/>

<dt class="string readonly">key</dt>	<dd>the character that was last pressed</dd>
<dt class="number readonly">keyCode</dt>	<dd>the integer that represents the key that was last pressed</dd>

<hr/>

<dt class="boolean readonly">keyPressed</dt>	<dd>true if a key is pressed</dd>
<dt class="boolean readonly">mousePressed</dt>	<dd>true if the mouse is pressed</dd>

<hr/>

<dt class="boolean">loop</dt>	<dd>if true, draw is fired repeatedly <span class="hint"><code>loop</code> is true by default.</span></dd>

</dl>
<div class="clear"></div>
<footer>By <a href="http://georgemichaelbrower.com/">George Michael Brower</a> and <a href="http://jonobr1.com/">Jono Brandel</a> of the Data Arts Team, Google Creative Lab.</footer>
</div>
</body>
</html>